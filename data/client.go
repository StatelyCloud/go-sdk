package data

import (
	"context"

	"connectrpc.com/connect"
	"github.com/planetscale/vtprotobuf/codec/grpc"

	"github.com/StatelyCloud/go-sdk/client"
	"github.com/StatelyCloud/go-sdk/pb/data/dataconnect"
)

type dataClient struct {
	client  dataconnect.DataClient
	storeID client.StoreID
}

// Client is a stately data client that interacts with the given store.
type Client interface {
	// GetBatch retrieves one or more Items by their full key paths. This will return any
	// of the Items that exist. It will fail if not all of the GetItem requests are
	// under the same root item path, or if the caller does not have permission to
	// read Items. Use Query if you want to retrieve multiple items but don't
	// already know the full key paths of the items you want to get.
	GetBatch(ctx context.Context, request GetRequest) ([]*RawItem, error)

	// Get retrieves one Item by their full key paths. It will fail if the caller does
	// not have permission to read Items. Use Query if you want to retrieve multiple
	// items but don't already know the full key paths of the items you want to get.
	// Use GetBatch if you want to retrieve multiple items by their full key paths.
	Get(ctx context.Context, itemPath string, options ...GetOptions) (*RawItem, error)

	// PutBatch adds one or more Items to the Store, or replaces the Items if they
	// already exist at that path.
	//
	// This will fail if
	//   - not all the PutData requests are under the same root item path.
	//   - any of the PutData requests' write conditions fails.
	//   - the caller does not have permission to create Items.
	//
	// Additional Notes:
	// All puts in the request are applied atomically - there are no partial
	// successes. Data can be provided as either JSON, or as a proto encoded by a
	// previously agreed upon schema, or by some combination of the two.
	PutBatch(ctx context.Context, request PutBatchRequest) ([]*PutBatchResponse, error)

	// Put adds one Item to the Store, or replaces the Item if it
	// already exists at that path.
	//
	// This will fail if:
	//   - The caller does not have permission to create Items.
	//
	// Additional Notes:
	// The PutData is applied atomically - there are no partial
	// successes. Data can be provided as a struct that can be
	// marshalled/unmarshalled as JSON, or a struct that can be
	// serialized/deserialized as a proto.
	Put(ctx context.Context, path string, value any) (*RawItem, error)

	// AppendBatch adds one or more new Items to a parent path, automatically assigning
	// IDs via one of several selectable ID generation strategies (not all
	// strategies may be available to all store configurations or path types).
	// The new item is guaranteed not to overwrite an existing Item because the ID
	// is generated by the server. This differs from Put specifically because
	// of this ID assignment behavior, and it is recommended over Put for new
	// items where you do not want to assign IDs yourself. The assigned IDs will
	// be returned in the response. This operation will fail if the caller does
	// not have permission to create Items.
	AppendBatch(ctx context.Context, request AppendBatchRequest) ([]*AppendBatchResponse, error)

	// Append one new Items to a parent path, automatically assigning
	// an ID via one of several selectable ID generation strategies (not all
	// strategies may be available to all store configurations or path types).
	// The new item is guaranteed not to overwrite an existing Item because the ID
	// is generated by the server. This differs from Put specifically because
	// of this ID assignment behavior, and it is recommended over Put for new
	// items where you do not want to assign IDs yourself. The assigned ID will
	// be returned in the response. This operation will fail if the caller does
	// not have permission to create Items.
	Append(
		ctx context.Context,
		parentPath, itemType string,
		idAssignment AppendIDAssignment,
		data any,
	) (*RawItem, error)

	// DeleteBatch removes one or more Items from the Store by their full key paths. This
	// will fail if any Item does not exist, if not all of the DeleteItem requests
	// are under the same root item path, or if the caller does not have permission
	// to delete Items. Tombstones will be left for deleted items for some
	// predetermined time (TBD tombstone behavior). All deletes in the request are
	// applied atomically - there are no partial successes.
	DeleteBatch(ctx context.Context, request DeleteRequest) ([]*DeleteResponse, error)

	// Delete removes one Item from the Store by their full key paths. This
	// will fail if the Item does not exist, or if the caller does not have permission
	// to delete Items. Tombstones will be left for deleted items for some
	// predetermined time (TBD tombstone behavior).
	Delete(ctx context.Context, itemPath string) error

	// BeginList loads Items that start with a specified key path, subject to
	// additional filtering. The prefix must minimally contain a Group Key (an
	// item type and an item ID). BeginList will return an empty result set if
	// there are no items matching that key prefix. A token is returned from this
	// API that you can then pass to ContinueList to expand the result set, or to
	// SyncList to get updates within the result set. This can fail if the caller
	// does not have permission to read Items.
	BeginList(ctx context.Context, keyPath string, opts ...ListOptions) (ListResponse[*RawItem], error)

	// ContinueList takes the token from a BeginList call and returns the next
	// "page" of results based on the original query parameters and pagination
	// options. It has few options because it is a continuation of a previous list
	// operation. It will return a new  token which can be used for another
	// ContinueList call, and so on. The  token is the same one used by SyncList -
	// each time you call either ContinueList or SyncList, you should pass the
	// latest version of the token, and then use the new token from the result in
	// subsequent calls. You may interleave ContinueList and SyncList calls
	// however you like, but it does not make sense to make both calls in
	// parallel. Calls to ContinueList are tied to the authorization of the
	// original BeginList call, so if the original BeginList call was allowed,
	// ContinueList with its token should also be allowed.
	ContinueList(ctx context.Context, token []byte) (ListResponse[*RawItem], error)

	// NewTransaction starts a new transaction on a stream, and calls the handler with a Transaction object.
	// The handler can then interact with the transaction by calling Get, Put, Append, Delete, and List.
	// The transaction is committed when the handler returns, and the results are returned.
	NewTransaction(ctx context.Context, handler TransactionHandler) (*TransactionResults, error)

	// SyncList returns an iterator for a sync operation.
	SyncList(ctx context.Context, token []byte) (ListResponse[SyncResponse], error)
}

// TransactionResults holds all the results of a transaction after a commit.
type TransactionResults struct {
	// PutResponse contains the full result of each Put operation. This only comes
	// back with the transaction is finished message because full metadata isn't
	// available until then.
	PutResponse []*PutBatchResponse

	// AppendResponse contains the full result of each Append operation. This only
	// comes back with the TransactionFinished message because full metadata isn't
	// available until then.
	AppendResponse []*AppendBatchResponse

	// DeleteResponse contains the full result of each Delete operation. This only
	// comes back with the TransactionFinished message because full metadata isn't
	// available until then.
	DeleteResponse []*DeleteResponse

	// Did the commit finish (the alternative is that it was aborted/rolled back)
	Committed bool
}

// Transaction represents a single transaction.
type Transaction interface {
	// Get one RawItem by its full key path.
	Get(item string) (*RawItem, error)

	// GetBatch one or more Items by their full key paths.
	GetBatch(items ...string) ([]*RawItem, error)

	// Put is a convenience method for adding a single Item to the Store, or replacing the RawItem if it exists at that path.
	Put(keyPath string, data any) error

	// PutBatch adds one or more Items to the Store, or replaces the Items if they exist at that path.
	// The metadata (create time/version + modified time/version)  for each PutData is returned only at the end of the transaction.
	PutBatch(items ...*PutData) error

	// Append adds one Item to a parent path, automatically assigning an ID.
	Append(prefix, itemType string, data any, idAssignment AppendIDAssignment) (string, error)

	// AppendBatch adds one or more new Items to a parent path, automatically assigning IDs.
	// The metadata (create time/version + modified time/version) for each AppendRequest is returned only at the end of the transaction.
	AppendBatch(prefix string, items ...*AppendRequest) ([]string, error)

	// Delete removes one or more Items from the Store by their full key paths.
	Delete(items ...string) error

	// BeginList loads Items that start with a specified key path, subject to additional filtering.
	// The returned ListResponse can be used to iterate over the stream of results for example:
	//	iter, err := txn.BeginList("/path/to/items")
	//	// handle err
	//	for iter.Continue() {
	//		item := iter.Item()
	//		// do something with item
	//	}
	//	err, token := iter.Token();
	//	// handle err and token
	BeginList(prefix string, options ...*ListOptions) (ListResponse[*RawItem], error)

	// ContinueList picks back up where this token left off. As with BeginList, you use the ListResponse to iterate over
	// the stream of results.
	ContinueList(token *ListToken) (ListResponse[*RawItem], error)
}

// TransactionHandler operates on a single transaction.
//
// The Transaction argument is passed to the handler function to allow the handler to interact with the transaction.
// This handler is not thread safe and should not be shared between goroutines. Additionally, do not share state outside
// the transaction handler. e.g. don't use a closure that captures variables from the outer scope.
//
// If you wish to cancel/abort the transaction, simply return an error from the handler and we'll take care of cleaning
// up the transaction.
type TransactionHandler func(Transaction) error

// NewClient creates a new client with the given store and options.
func NewClient(appCtx context.Context, storeID client.StoreID, options ...*client.Options) (Client, error) {
	opts := &client.Options{}
	for _, o := range options {
		opts = opts.Merge(o)
	}
	opts, err := opts.ApplyDefaults(appCtx)
	if err != nil {
		return nil, err
	}

	return &dataClient{
		client:  dataconnect.NewDataClient(opts.HTTPClient(), opts.Endpoint, connect.WithCodec(grpc.Codec{})),
		storeID: storeID,
	}, nil
}
