package data

import (
	"context"
	"errors"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/structpb"

	"github.com/StatelyCloud/go-sdk/internal"
	pb "github.com/StatelyCloud/go-sdk/pb/data"
)

// Append adds one Item to a parent path, automatically assigning
// an ID via one of several selectable ID generation strategies (not all
// strategies may be available to all store configurations or path types).
// The new item is guaranteed not to overwrite an existing Item because the ID
// is generated by the server. This differs from Put specifically because
// of this ID assignment behavior, and it is recommended over Put for new
// items where you do not want to assign IDs yourself. The assigned IDs will
// be returned in the response. This operation will fail if the caller does
// not have permission to create Items.
func (c *dataClient) Append(
	ctx context.Context,
	parentPath string,
	itemType string,
	idAssignment AppendIDAssignment,
	data any,
) (*RawItem, error) {
	responses, err := c.AppendBatch(ctx, AppendBatchRequest{
		AppendRequests: []*AppendRequest{
			{
				ItemType:     itemType,
				Data:         data,
				IDAssignment: idAssignment,
			},
		},
		ParentPath: parentPath,
	})
	if err != nil {
		return nil, err
	}
	response := responses[0]
	return response.RawItem, response.Error
}

// AppendBatchRequest allows you to specify more than 1 item you wish to append to any group.
type AppendBatchRequest struct {
	// AppendRequests allows you to set
	AppendRequests []*AppendRequest
	// (option) Atomic indicates that all deletes must succeed or none will (i.e. that they
	// are applied in a transaction), and that other operations will be serialized
	// ahead or behind this operation.
	Atomic IsAtomic
	// ParentPath is the path all these items share.
	// Example: [/state-washington/city-seattle]/[person]-<id> the first group is the ParentPath, and the second is the ItemType
	ParentPath string
}

// AppendRequest allows you to set the appendID strategy per item.
type AppendRequest struct {
	// ItemType "is the item path without the "id" part because we're appending it.
	// Example: "person-<id>" you would omit the "-<id>" for "person"
	ItemType string
	// You JSON or proto data to append.
	Data any
	// IDAssignment allows per item append id assignment. Read AppendIDAssignment for more choices.
	IDAssignment AppendIDAssignment
}

// AppendBatchResponse is a tuple of *RawItem[T] OR error. If there's an error, RawItem will be nil with a description of why.
type AppendBatchResponse struct {
	RawItem *RawItem
	Error   error
}

// AppendBatch adds one or more new Items to a parent path, automatically assigning
// IDs via one of several selectable ID generation strategies (not all
// strategies may be available to all store configurations or path types).
// The new item is guaranteed not to overwrite an existing Item because the ID
// is generated by the server. This differs from Put specifically because
// of this ID assignment behavior, and it is recommended over Put for new
// items where you do not want to assign IDs yourself. The assigned IDs will
// be returned in the response. This operation will fail if the caller does
// not have permission to create Items.
func (c *dataClient) AppendBatch(
	ctx context.Context,
	batchRequest AppendBatchRequest,
) ([]*AppendBatchResponse, error) {
	appendRequests := batchRequest.AppendRequests
	appendItems, appendData, err := mapAppendRequest(appendRequests)
	if err != nil {
		return nil, err
	}

	response, err := c.client.Append(ctx, connect.NewRequest(&pb.AppendRequest{
		StoreId:    uint64(c.storeID),
		ParentPath: batchRequest.ParentPath,
		Appends:    appendItems,
		Atomic:     bool(batchRequest.Atomic),
	}))
	if err != nil {
		return nil, err
	}

	responses := mapAppendResponses(response.Msg.GetResults(), appendData)

	return responses, nil
}

// shared between transactional and non-transactional append.
func mapAppendResponses(
	response []*pb.AppendItemResult,
	appendData []*parsedData[*structpb.Struct],
) []*AppendBatchResponse {
	responses := make([]*AppendBatchResponse, len(response))
	for i, v := range response {
		item := &RawItem{
			JSONData: appendData[i].getJSONData(),
		}

		if err := v.GetError(); err != nil {
			responses[i] = &AppendBatchResponse{
				RawItem: item, // this item is partially filled but might be useful for debugging?
				Error:   internal.MapProtoError(err),
			}
			continue
		}

		item = setProtoMetadata(v.GetMetadata(), item)
		item, err := setKeyPath(v.GetKeyPath(), item)
		if err != nil {
			responses[i] = &AppendBatchResponse{
				RawItem: item, // this item is partially filled but might be useful for debugging?
				Error:   err,
			}
			continue
		}

		responses[i] = &AppendBatchResponse{
			RawItem: item,
		}
	}
	return responses
}

// shared between transactional and non-transactional append.
func mapAppendRequest(requests []*AppendRequest) ([]*pb.AppendItem, []*parsedData[*structpb.Struct], error) {
	appendItems := make([]*pb.AppendItem, len(requests))
	jsonData := make([]*parsedData[*structpb.Struct], len(requests))
	for i, v := range requests {
		if v.IDAssignment == AppendIDAssignment(0) {
			return nil, nil, connect.NewError(connect.CodeInvalidArgument, errors.New("IDAssignment is required"))
		}

		jsonStruct, protoMsg, err := dataToProto(v.Data)
		if err != nil {
			return nil, nil, err
		}
		jsonData[i] = jsonStruct
		appendItems[i] = &pb.AppendItem{
			ItemType:     v.ItemType,
			IdAssignment: pb.AppendItem_IDAssignment(v.IDAssignment),
			Json:         jsonStruct.getJSONParsed(),
			Proto:        protoMsg,
		}
	}
	return appendItems, jsonData, nil
}
